
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=ascii" />
    <title>9. Structures and Records &#8212; Theorem Proving in Lean 3.3.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="10. Type Classes" href="type_classes.html" />
    <link rel="prev" title="8. Induction and Recursion" href="induction_and_recursion.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="structures-and-records">
<span id="id1"></span><h1>9. Structures and Records<a class="headerlink" href="#structures-and-records" title="Permalink to this headline">&#182;</a></h1>
<p>We have seen that Lean&#8217;s foundational system includes inductive types. We have, moreover, noted that it is a remarkable fact that it is possible to construct a substantial edifice of mathematics based on nothing more than the type universes, Pi types, and inductive types; everything else follows from those. The Lean standard library contains many instances of inductive types (e.g., <code class="docutils literal"><span class="pre">nat</span></code>, <code class="docutils literal"><span class="pre">prod</span></code>, <code class="docutils literal"><span class="pre">list</span></code>), and even the logical connectives are defined using inductive types.</p>
<p>Remember that a non-recursive inductive type that contains only one constructor is called a <em>structure</em> or <em>record</em>. The product type is a structure, as is the dependent product type, that is, the Sigma type. In general, whenever we define a structure <code class="docutils literal"><span class="pre">S</span></code>, we usually define <em>projection</em> functions that allow us to &#8220;destruct&#8221; each instance of <code class="docutils literal"><span class="pre">S</span></code> and retrieve the values that are stored in its fields. The functions <code class="docutils literal"><span class="pre">prod.pr1</span></code> and <code class="docutils literal"><span class="pre">prod.pr2</span></code>, which return the first and second elements of a pair, are examples of such projections.</p>
<p>When writing programs or formalizing mathematics, it is not uncommon to define structures containing many fields. The <code class="docutils literal"><span class="pre">structure</span></code> command, available in Lean, provides infrastructure to support this process. When we define a structure using this command, Lean automatically generates all the projection functions. The <code class="docutils literal"><span class="pre">structure</span></code> command also allows us to define new structures based on previously defined ones. Moreover, Lean provides convenient notation for defining instances of a given structure.</p>
<div class="section" id="declaring-structures">
<h2>9.1. Declaring Structures<a class="headerlink" href="#declaring-structures" title="Permalink to this headline">&#182;</a></h2>
<p>The structure command is essentially a &#8220;front end&#8221; for defining inductive data types. Every <code class="docutils literal"><span class="pre">structure</span></code> declaration introduces a namespace with the same name. The general form is as follows:</p>
<div class="highlight-text"><div class="highlight"><pre>structure &lt;name&gt; &lt;parameters&gt; &lt;parent-structures&gt; : Sort u :=
  &lt;constructor&gt; :: &lt;fields&gt;
</pre></div>
</div>
<p>Most parts are optional. Here is an example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">point</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Values of type <code class="docutils literal"><span class="pre">point</span></code> are created using <code class="docutils literal"><span class="pre">point.mk</span> <span class="pre">a</span> <span class="pre">b</span></code>, and the fields of a point <code class="docutils literal"><span class="pre">p</span></code> are accessed using <code class="docutils literal"><span class="pre">point.x</span> <span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">point.y</span> <span class="pre">p</span></code>. The structure command also generates useful recursors and theorems. Here are some of the constructions generated for the declaration above.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%0A%0A--%20BEGIN%0A#check%20point%20%20%20%20%20%20%20%20%20%20%20%20%20%20--%20a%20Type%0A#check%20point.rec_on%20%20%20%20%20%20%20--%20the%20eliminator%0A#check%20point.x%20%20%20%20%20%20%20%20%20%20%20%20--%20a%20projection%20/%20field%20accessor%0A#check%20point.y%20%20%20%20%20%20%20%20%20%20%20%20--%20a%20projection%20/%20field%20accessor%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="k">#check</span> <span class="n">point</span>              <span class="c1">-- a Type</span>
<span class="k">#check</span> <span class="n">point.rec_on</span>       <span class="c1">-- the eliminator</span>
<span class="k">#check</span> <span class="n">point.x</span>            <span class="c1">-- a projection / field accessor</span>
<span class="k">#check</span> <span class="n">point.y</span>            <span class="c1">-- a projection / field accessor</span>
</pre></div>
</div>
</div><p>You can obtain the complete list of generated constructions using the command <code class="docutils literal"><span class="pre">#print</span> <span class="pre">prefix</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%0A%0A--%20BEGIN%0A#print%20prefix%20point%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="k">#print</span> <span class="kd">prefix</span> <span class="n">point</span>
</pre></div>
</div>
</div><p>Here are some simple theorems and expressions that use the generated constructions. As usual, you can avoid the prefix <code class="docutils literal"><span class="pre">point</span></code> by using the command <code class="docutils literal"><span class="pre">open</span> <span class="pre">point</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%0A%0A--%20BEGIN%0A#reduce%20point.x%20(point.mk%2010%2020)%0A#reduce%20point.y%20(point.mk%2010%2020)%0A%0Aopen%20point%0A%0Aexample%20(%CE%B1%20:%20Type)%20(a%20b%20:%20%CE%B1)%20:%20x%20(mk%20a%20b)%20=%20a%20:=%0Arfl%0A%0Aexample%20(%CE%B1%20:%20Type)%20(a%20b%20:%20%CE%B1)%20:%20y%20(mk%20a%20b)%20=%20b%20:=%0Arfl%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="k">#reduce</span> <span class="n">point.x</span> <span class="o">(</span><span class="n">point.mk</span> <span class="mi">10</span> <span class="mi">20</span><span class="o">)</span>
<span class="k">#reduce</span> <span class="n">point.y</span> <span class="o">(</span><span class="n">point.mk</span> <span class="mi">10</span> <span class="mi">20</span><span class="o">)</span>

<span class="kn">open</span> <span class="n">point</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="o">(</span><span class="n">mk</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">rfl</span>
</pre></div>
</div>
</div><p>Given <code class="docutils literal"><span class="pre">p</span> <span class="pre">:</span> <span class="pre">point</span> <span class="pre">nat</span></code>, the notation <code class="docutils literal"><span class="pre">p.x</span></code> is shorthand for <code class="docutils literal"><span class="pre">point.x</span> <span class="pre">p</span></code>. This provides a convenient way of accessing the fields of a structure.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%0A%0A--%20BEGIN%0Adef%20p%20:=%20point.mk%2010%2020%0A%0A#check%20p.x%20--%20nat%0A#reduce%20%20p.x%20--%2010%0A#reduce%20%20p.y%20--%2020%0A--%20END" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">def</span> <span class="n">p</span> <span class="o">:=</span> <span class="n">point.mk</span> <span class="mi">10</span> <span class="mi">20</span>

<span class="k">#check</span> <span class="n">p.x</span> <span class="c1">-- nat</span>
<span class="k">#reduce</span>  <span class="n">p.x</span> <span class="c1">-- 10</span>
<span class="k">#reduce</span>  <span class="n">p.y</span> <span class="c1">-- 20</span>
</pre></div>
</div>
</div><p>If the constructor is not provided, then a constructor is named <code class="docutils literal"><span class="pre">mk</span></code> by default.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=namespace%20hide%0A--%20BEGIN%0Astructure%20prod%20(%CE%B1%20:%20Type)%20(%CE%B2%20:%20Type)%20:=%0A(pr1%20:%20%CE%B1)%20(pr2%20:%20%CE%B2)%0A%0A#check%20prod.mk%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">prod</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">(</span><span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pr1</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">pr2</span> <span class="o">:</span> <span class="n">&#946;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">prod.mk</span>
</pre></div>
</div>
</div><p>You can provide universe levels explicitly. The annotations in the next example force the parameters <code class="docutils literal"><span class="pre">&#945;</span></code> and <code class="docutils literal"><span class="pre">&#946;</span></code> to be types from the same universe, and set the return type to also be in the same universe.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=namespace%20hide%0A--%20BEGIN%0Astructure%20%7Bu%7D%20prod%20(%CE%B1%20:%20Type%20u)%20(%CE%B2%20:%20Type%20u)%20:%0A%20%20Type%20(max%201%20u)%20:=%0A(pr1%20:%20%CE%B1)%20(pr2%20:%20%CE%B2)%0A%0Aset_option%20pp.universes%20true%0A#check%20prod.mk%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">prod</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="mi">1</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pr1</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">pr2</span> <span class="o">:</span> <span class="n">&#946;</span><span class="o">)</span>

<span class="kd">set_option</span> <span class="n">pp.universes</span> <span class="n">true</span>
<span class="k">#check</span> <span class="n">prod.mk</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal"><span class="pre">set_option</span></code> command above instructs Lean to display the universe levels.</p>
<p>We use <code class="docutils literal"><span class="pre">max</span> <span class="pre">1</span> <span class="pre">l</span></code> as the resultant universe level to ensure the universe level is never <code class="docutils literal"><span class="pre">0</span></code> even when the parameter <code class="docutils literal"><span class="pre">&#945;</span></code> and <code class="docutils literal"><span class="pre">&#946;</span></code> are propositions. Recall that in Lean, <code class="docutils literal"><span class="pre">Type</span> <span class="pre">0</span></code> is <code class="docutils literal"><span class="pre">Prop</span></code>, which is impredicative and proof irrelevant.</p>
<p>We can use the anonymous constructor notation to build structure values whenever the expected type is known.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=namespace%20hide%0A--%20BEGIN%0Astructure%20%7Bu%7D%20prod%20(%CE%B1%20:%20Type%20u)%20(%CE%B2%20:%20Type%20u)%20:%0A%20%20Type%20(max%201%20u)%20:=%0A(pr1%20:%20%CE%B1)%20(pr2%20:%20%CE%B2)%0A%0Aexample%20:%20prod%20nat%20nat%20:=%0A%E2%9F%A81,%202%E2%9F%A9%0A%0A#check%20(%E2%9F%A81,%202%E2%9F%A9%20:%20prod%20nat%20nat)%0A--%20END%0Aend%20hide" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">prod</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span>
  <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="mi">1</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">pr1</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">pr2</span> <span class="o">:</span> <span class="n">&#946;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">prod</span> <span class="n">nat</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">&#10217;</span>

<span class="k">#check</span> <span class="o">(&#10216;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">&#10217;</span> <span class="o">:</span> <span class="n">prod</span> <span class="n">nat</span> <span class="n">nat</span><span class="o">)</span>
</pre></div>
</div>
</div></div>
<div class="section" id="objects">
<h2>9.2. Objects<a class="headerlink" href="#objects" title="Permalink to this headline">&#182;</a></h2>
<p>We have been using constructors to create elements of a structure type. For structures containing many fields, this is often inconvenient, because we have to remember the order in which the fields were defined. Lean therefore provides the following alternative notations for defining elements of a structure type.</p>
<div class="highlight-text"><div class="highlight"><pre>{ structure-name . (&lt;field-name&gt; := &lt;expr&gt;)* }
or
{ (&lt;field-name&gt; := &lt;expr&gt;)* }
</pre></div>
</div>
<p>The prefix <code class="docutils literal"><span class="pre">structure-name</span> <span class="pre">.</span></code> can be omitted whenever the name of the structure can be inferred from the expected type. For example, we use this notation to define &#8220;points.&#8221; The order that the fields are specified does not matter, so all the expressions below define the same point.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%0A%0A#check%20%7B%20point%20.%20x%20:=%2010,%20y%20:=%2020%20%7D%20%20%20--%20point%20%E2%84%95%0A#check%20%7B%20point%20.%20y%20:=%2020,%20x%20:=%2010%20%7D%0A#check%20(%7Bx%20:=%2010,%20y%20:=%2020%7D%20:%20point%20nat)%0A%0Aexample%20:%20point%20nat%20:=%0A%7B%20y%20:=%2020,%20x%20:=%2010%20%7D" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">point</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">{</span> <span class="n">point</span> <span class="bp">.</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">20</span> <span class="o">}</span>   <span class="c1">-- point &#8469;</span>
<span class="k">#check</span> <span class="o">{</span> <span class="n">point</span> <span class="bp">.</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">10</span> <span class="o">}</span>
<span class="k">#check</span> <span class="o">({</span><span class="n">x</span> <span class="o">:=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">20</span><span class="o">}</span> <span class="o">:</span> <span class="n">point</span> <span class="n">nat</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">point</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">20</span><span class="o">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">10</span> <span class="o">}</span>
</pre></div>
</div>
</div><p>If the value of a field is not specified, Lean tries to infer it. If the unspecified fields cannot be inferred, Lean signs an error indicating the corresponding placeholder could not be synthesized.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20my_struct%20:=%0Amk%20::%20%7B%CE%B1%20:%20Type%7D%20%7B%CE%B2%20:%20Type%7D%20(a%20:%20%CE%B1)%20(b%20:%20%CE%B2)%0A%0A#check%20%7B%20my_struct%20.%20a%20:=%2010,%20b%20:=%20true%20%7D" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">my_struct</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">{</span><span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">&#946;</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">{</span> <span class="n">my_struct</span> <span class="bp">.</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">true</span> <span class="o">}</span>
</pre></div>
</div>
</div><p><em>Record update</em> is another common operation. It consists in creating a new record object by modifying the value of one or more fields. Lean provides a variation of the notation described above for record updates.</p>
<div class="highlight-text"><div class="highlight"><pre>{ record-obj with (&lt;field-name&gt; := &lt;expr&gt;)* }
</pre></div>
</div>
<p>The semantics are straightforward: record objects <code class="docutils literal"><span class="pre">&lt;record-obj&gt;</span></code> provide the values for the unspecified fields. If more than one record object is provided, then they are visited in order until Lean finds one the contains the unspecified field. Lean raises an error if any of the field names remain unspecified after all the objects are visited.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%0A%0Adef%20p%20:%20point%20nat%20:=%0A%7Bx%20:=%201,%20y%20:=%202%7D%0A%0A#reduce%20%7Bp%20with%20y%20:=%203%7D%0A#reduce%20%7Bp%20with%20x%20:=%203%7D" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">point</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">p</span> <span class="o">:</span> <span class="n">point</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">x</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">}</span>

<span class="k">#reduce</span> <span class="o">{</span><span class="n">p</span> <span class="k">with</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">}</span>
<span class="k">#reduce</span> <span class="o">{</span><span class="n">p</span> <span class="k">with</span> <span class="n">x</span> <span class="o">:=</span> <span class="mi">3</span><span class="o">}</span>
</pre></div>
</div>
</div></div>
<div class="section" id="inheritance">
<h2>9.3. Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">&#182;</a></h2>
<p>We can <em>extend</em> existing structures by adding new fields. This feature allow us to simulate a form of <em>inheritance</em>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0Amk%20::%20(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%0A%0Ainductive%20color%0A%7C%20red%20%7C%20green%20%7C%20blue%0A%0Astructure%20color_point%20(%CE%B1%20:%20Type)%20extends%20point%20%CE%B1%20:=%0Amk%20::%20(c%20:%20color)" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">point</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="kd">inductive</span> <span class="n">color</span>
<span class="bp">|</span> <span class="n">red</span> <span class="bp">|</span> <span class="n">green</span> <span class="bp">|</span> <span class="n">blue</span>

<span class="kd">structure</span> <span class="n">color_point</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">point</span> <span class="n">&#945;</span> <span class="o">:=</span>
<span class="n">mk</span> <span class="o">::</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">color</span><span class="o">)</span>
</pre></div>
</div>
</div><p>In the next example, we define a structure using multiple inheritance, and then define an object using objects of the parent structures.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover.github.io/live/3.3.0/#code=structure%20point%20(%CE%B1%20:%20Type)%20:=%0A(x%20:%20%CE%B1)%20(y%20:%20%CE%B1)%20(z%20:%20%CE%B1)%0A%0Astructure%20rgb_val%20:=%0A(red%20:%20nat)%20(green%20:%20nat)%20(blue%20:%20nat)%0A%0Astructure%20red_green_point%20(%CE%B1%20:%20Type)%20extends%20point%20%CE%B1,%20rgb_val%20:=%0A(no_blue%20:%20blue%20=%200)%0A%0Adef%20p%20%20%20:%20point%20nat%20:=%20%7Bx%20:=%2010,%20y%20:=%2010,%20z%20:=%2020%7D%0Adef%20rgp%20:%20red_green_point%20nat%20:=%0A%7Bp%20with%20red%20:=%20200,%20green%20:=%2040,%20blue%20:=%200,%20no_blue%20:=%20rfl%7D%0A%0Aexample%20:%20rgp.x%20%20%20=%2010%20:=%20rfl%0Aexample%20:%20rgp.red%20=%20200%20:=%20rfl" target="_blank">
try it!</a></div><div class="highlight-lean"><div class="highlight"><pre><span class="kd">structure</span> <span class="n">point</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">z</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">rgb_val</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">red</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">green</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span> <span class="o">(</span><span class="n">blue</span> <span class="o">:</span> <span class="n">nat</span><span class="o">)</span>

<span class="kd">structure</span> <span class="n">red_green_point</span> <span class="o">(</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span> <span class="kd">extends</span> <span class="n">point</span> <span class="n">&#945;</span><span class="o">,</span> <span class="n">rgb_val</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">no_blue</span> <span class="o">:</span> <span class="n">blue</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">p</span>   <span class="o">:</span> <span class="n">point</span> <span class="n">nat</span> <span class="o">:=</span> <span class="o">{</span><span class="n">x</span> <span class="o">:=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">y</span> <span class="o">:=</span> <span class="mi">10</span><span class="o">,</span> <span class="n">z</span> <span class="o">:=</span> <span class="mi">20</span><span class="o">}</span>
<span class="kd">def</span> <span class="n">rgp</span> <span class="o">:</span> <span class="n">red_green_point</span> <span class="n">nat</span> <span class="o">:=</span>
<span class="o">{</span><span class="n">p</span> <span class="k">with</span> <span class="n">red</span> <span class="o">:=</span> <span class="mi">200</span><span class="o">,</span> <span class="n">green</span> <span class="o">:=</span> <span class="mi">40</span><span class="o">,</span> <span class="n">blue</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">no_blue</span> <span class="o">:=</span> <span class="n">rfl</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">rgp.x</span>   <span class="bp">=</span> <span class="mi">10</span> <span class="o">:=</span> <span class="n">rfl</span>
<span class="kd">example</span> <span class="o">:</span> <span class="n">rgp.red</span> <span class="bp">=</span> <span class="mi">200</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
</div></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Theorem Proving in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="dependent_type_theory.html">2. Dependent Type Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="propositions_and_proofs.html">3. Propositions and Proofs</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantifiers_and_equality.html">4. Quantifiers and Equality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">5. Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_lean.html">6. Interacting with Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="inductive_types.html">7. Inductive Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="induction_and_recursion.html">8. Induction and Recursion</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">9. Structures and Records</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#declaring-structures">9.1. Declaring Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#objects">9.2. Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inheritance">9.3. Inheritance</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="type_classes.html">10. Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="axioms_and_computation.html">11. Axioms and Computation</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
    <li class="toctree-l1"><a href="theorem_proving_in_lean.pdf">PDF version</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Jeremy Avigad, Leonardo de Moura, and Soonho Kong.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/structures_and_records.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>